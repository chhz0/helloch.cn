---
prev:
  text: '架构 - redisDb'
  link: '/redis/arch/redisDb'
next:
  text: '架构 - 多线程持久化'
  link: 'redis/arch/multi-thread-persistence'
---
# Redis 单线程模型 <Badge type="tip" text="Redis Single Thread" />

redis是一个能高效处理请求的组件

核心处理逻辑：Redis一直都是单线程，其他辅助模块会有一些多线程、多进程的功能，例如：复制模块用的多进程；某些异步流程从4.0开始用多线程；网络I/O解包从6.0开始用多线程；

> Redis在处理客户端的请求时，包括获取（socket写）、解析、执行、内容返回等都是由一个顺序串行的主线程处理，这就是所谓的单线程

## Redis 单线程的选择

Redis的定位是内存k-v存储，是做短平快的热点数据处理，一般来说执行会很快，执行本身不会成为瓶颈，瓶颈通常在网络I/O，处理逻辑多线程并不会有太大收益

同时Redis本身秉持简洁高效的理念，代码的简单性、可维护性是redis一直依赖的追求，执行本身不应该成为瓶颈，而且多线程本身也会引起额外成本

### 引入多线程带来复杂度和额外成本
1. 多线程引入的复杂度是极大的
    - 多线程引入后，redis原来的顺序执行特性就不复存在，为了事务的原子性、隔离性，redis就不得不引入一些很复杂的实现
    - redis的数据结构是极其高效，在单线程模式下做了很多特性的优化，如果引入多线程，那么所有底层数据都要改为线性安全，这很复杂
    - 多线程模式使得程序调试更加复杂和麻烦，会带来额外的开发成本及运营成本

2. 多线程带来额外的成本
   - 上下文切换成本，多线程调度需要切换线程上下文，这个操作先存储当前线程的本地数据，程序指针，然后载入另一个线程数据，这种内核操作的成本不可忽略
   - 同步机制的开销，一些公共资源，在单线程模式下直接访问就行，多线程需要通过加锁等方式进行同步
   - 一个线程本身也占据内存大小，对redis这种内存数据库来说，内存非常珍贵，多线程本身带来的内存使用的成本也需要谨慎决策

## Redis 单线程的高性能

Redis 核心的请求处理是`单线程`，但是Redis却能使用单线程模型达到每秒数万级别的处理能力，这是Redis多方面极致设计的一个综合结果.

1. Redis的大部分操作在内存上完成，内存操作本身就特别快
2. Redis选择了很多高效的数据结构，并做了很多优化，比如`ziplist`，`hash`，`skiplist`等，有时候一种对象底层有几种实现以应对不同场景
3. Redis采用了多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞并量

### Redis I/O多路复用

Redis在内存中处理数据，其性能瓶颈更多是在I/O

Redis的I/O多路复用机制，是指Redis在处理客户端请求时，通过使用操作系统提供的I/O多路复用功能，实现同时处理多个客户端的请求，而不是阻塞等待每个请求的处理完成

Redis做了一层包装，叫`Reactor模型`，本质就是监听各种事件，当事件发生时，将事件分发给不同的处理器

![redis-reactor](../../public/redis/redis-reactor.drawio.svg)

I/O多路复用让redis单线程有了较大的并发度，这里是并发，不是并行，这种模式下，Redis单核的性能可以是被充分利用
